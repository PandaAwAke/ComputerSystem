# XXF组内对接操作手册



| 编号 | 名称  |                     约定                     |
| :--: | :---: | :------------------------------------------: |
|  0   | zero  |             初始为0，不应该修改              |
|  26  |  k0   | 初始为0x7fff0000，指示输入内容放置的起始地址 |
|  27  |  k1   |          control register，初始为0           |
|  29  |  sp   |           栈指针，初始为0x7fffeffc           |
|  31  |  ra   |                   返回地址                   |
|      | lo,hi |                 乘除法的结果                 |
|      |  pc   |          指令计数器，初始为0x400000          |

control register的说明

| 位数 |                        含义                        |
| :--: | :------------------------------------------------: |
|  0   | 为1进入调试模式，使用按钮，每条指令输出PC和指令码  |
|  1   |        为1表示需要输出内容，cpu输出完会置0         |
|  2   |        为1表示需要输入内容，cpu输入完会置0         |
|  3   |         为1表示程序执行结束，cpu之后会置0          |
|  4   | 为1表示开启键盘音效，开机时为0，之后完全由程序控制 |

指令条数最多为1024条

内存最多放16K个32bit，这就是说内存地址的低2位应始终为0，只能放32位的数

做了一个简单的地址映射，数据段物理地址为虚拟地址的低16位，代码段物理地址为虚拟地址的低12位

数据和代码放在两个不同的区域，不能相互访问

初始时会自动先读入，读入的字符会放在从k0(0x0000)开始的内存中，每32bit放一个字符，0表示结束

之后若请求读入需先设置k0，不改也可以。程序运行时应该可以随便用（不建议），仅在请求读入时正确设置。

读入都只能读一行，以0结尾。

程序需要输出时需依次把需要输出的字符放在sp开始的内存中，每32bit放一个字符，0表示**换行**（也就是说依次从最后一位（结束符0）到第一位压栈）。最后把字符串长度（包含末尾的0，即最少为1）压在(sp)处。一次最多能输出多少个字符要问mss

zss的任务：生成`instr_ram.mif`，0x400000处的指令放在0处，以此类推

若有必要，生成`main_memory.mif`，但只有第一次有效，再次从头运行程序的时候没用

空指令nop为全0